#include <bits/stdc++.h>

using namespace std;

#define ll long long

const ll MOD = (ll)1e9+7;

struct segmentTree{
    ll sum;
    ll lazy;
    segmentTree *left, *right;
    segmentTree(){
        ll sum = 0;
        ll lazy = 0;
        left = nullptr;
        right = nullptr;
    }
};

segmentTree* build(ll i, ll j, ll arreglo[]){
    segmentTree *root = new segmentTree();
    root->lazy=0;
    if(i==j){
        root->sum = (arreglo[i]%MOD);
        return root;
    }
    ll mid = (i+j)/2;
    root->left = build(i,mid,arreglo);
    root->right = build(mid+1,j,arreglo);
    root->sum = (root->left->sum + root->right->sum)%MOD;
    return root;
}

long long answer(segmentTree *current, ll i, ll j, const ll idxQ1, const ll idxQ2){
    if(i>idxQ2 || j<idxQ1)return 0;
    if(i>=idxQ1 && j<=idxQ2){
        return (current->sum)%MOD;
    }
    ll mid=(i+j)/2;
    if(current->lazy>0){
        if(current->left!= nullptr){
            current->left->sum = (current->left->sum+((mid-i+1)*current->lazy)%MOD)%MOD;
            current->left->lazy = (current->left->lazy+current->lazy)%MOD;
        }
        if(current->right!= nullptr){
            current->right->sum = (current->right->sum + ((j-(mid+1)+1)*current->lazy)%MOD)%MOD;
            current->right->lazy = (current->right->lazy +current->lazy)%MOD;
        }
        current->lazy=0;

    }
    return (answer(current->left,i,mid,idxQ1,idxQ2) + answer(current->right,mid+1,j,idxQ1,idxQ2))%MOD;
}

segmentTree* update(segmentTree* current, ll i, ll j, const ll idxQ1, const ll idxQ2, const ll numero){
    if(i>idxQ2 || j<idxQ1) return current;
    if(i>=idxQ1 && j<=idxQ2){
        current->sum = (current->sum + ((j-i+1)*numero)%MOD)%MOD;
        current->lazy = (current->lazy + numero)%MOD;
        return current;
    }
    ll mid = (i+j)/2;
    if(current->lazy>0){
        if(current->left != nullptr){
            current->left->sum = (current->left->suml + ((mid-i+1)*current->lazy)%MOD)%MOD;
            current->left->lazy = (current->left->lazy + current->lazy)%MOD;
        }
        if(current->right != nullptr){
            current->right->sum = (current->right->sum + ((j-(mid+1)+1)*current->lazy)%MOD)%MOD;
            current->right->lazy = (current->right->lazy + current->lazy)%MOD;
        }
        current->lazy=0;
    }
    current->left= update(current->left,i,mid,idxQ1, idxQ2, numero);
    current->right= update(current->right,mid+1,j,idxQ1, idxQ2, numero);
    current->sum= (current->left->sum+current->right->sum)%MOD;
  
