#include <bits/stdc++.h>

using namespace std;

#define ll long long

const ll MOD = (ll)1e9+7;

struct segmentTree{
    ll sum;
    ll lazy;
    segmentTree *izq, *der;
    segmentTree(){
        suma_cuadrados = 0;
        ll sum = 0;
        ll lazy = 0;
        izq = nullptr;
        der = nullptr;
    }
};

segmentTree* build(ll i, ll j, ll arreglo[]){
    segmentTree *root = new segmentTree();
    root->lazy=0;
    if(i==j){
        root->sum = (arreglo[i]%MOD);
        return root;
    }
    ll mitad = (i+j)/2;
    root->izq = build(i,mitad,arreglo);
    root->der = build(mitad+1,j,arreglo);
    root->sum = (root->izq->sum + root->der->sum)%MOD;
    return root;
}

long long answer(segmentTree *current, ll i, ll j, const ll idxQ1, const ll idxQ2){
    if(i>idxQ2 || j<idxQ1)return 0;
    if(i>=idxQ1 && j<=idxQ2){
        return (current->sum)%MOD;
    }
    ll mitad=(i+j)/2;
    if(current->lazy>0){
        if(current->izq!= nullptr){
            current->izq->sum = (current->izq->sum+((mitad-i+1)*current->lazy)%MOD)%MOD;
            current->izq->lazy = (current->izq->lazy+current->lazy)%MOD;
        }
        if(current->der!= nullptr){
            current->der->sum = (current->der->sum + ((j-(mitad+1)+1)*current->lazy)%MOD)%MOD;
            current->der->lazy = (current->der->lazy +current->lazy)%MOD;
        }
        current->lazy=0;

    }
    return (answer(current->izq,i,mitad,idxQ1,idxQ2) + answer(current->der,mitad+1,j,idxQ1,idxQ2))%MOD;
}

segmentTree* update(segmentTree* current, ll i, ll j, const ll idxQ1, const ll idxQ2, const ll numero){
    if(i>idxQ2 || j<idxQ1) return current;
    if(i>=idxQ1 && j<=idxQ2){
        current->sum = (current->sum + ((j-i+1)*numero)%MOD)%MOD;
        current->lazy = (current->lazy + numero)%MOD;
        return current;
    }
    ll mitad = (i+j)/2;
    if(current->lazy>0){
        if(current->izq != nullptr){
            current->izq->sum = (current->izq->suml + ((mitad-i+1)*current->lazy)%MOD)%MOD;
            current->izq->lazy = (current->izq->lazy + current->lazy)%MOD;
        }
        if(current->der != nullptr){
            current->der->sum = (current->der->sum + ((j-(mitad+1)+1)*current->lazy)%MOD)%MOD;
            current->der->lazy = (current->der->lazy + current->lazy)%MOD;
        }
        current->lazy=0;
    }
    current->izq= update(current->izq,i,mitad,idxQ1, idxQ2, numero);
    current->der= update(current->der,mitad+1,j,idxQ1, idxQ2, numero);
    current->suma_normal= (current->izq->suma_normal+current->der->suma_normal)%MOD;
  
